#pragma once

#define IB_OPCODE(transport, op) \
	IB_OPCODE_ ## transport ## _ ## op = \
		IB_OPCODE_ ## transport + IB_OPCODE_ ## op

#define BIT(n) (1UL << (n))

enum {
    /* transport types -- just used to define real constants */
    IB_OPCODE_RC = 0x00,

    /* operations -- just used to define real constants */
    IB_OPCODE_SEND_FIRST = 0x00,
    IB_OPCODE_SEND_MIDDLE = 0x01,
    IB_OPCODE_SEND_LAST = 0x02,
    IB_OPCODE_SEND_LAST_WITH_IMMEDIATE = 0x03,
    IB_OPCODE_SEND_ONLY = 0x04,
    IB_OPCODE_SEND_ONLY_WITH_IMMEDIATE = 0x05,
    IB_OPCODE_RDMA_WRITE_FIRST = 0x06,
    IB_OPCODE_RDMA_WRITE_MIDDLE = 0x07,
    IB_OPCODE_RDMA_WRITE_LAST = 0x08,
    IB_OPCODE_RDMA_WRITE_LAST_WITH_IMMEDIATE = 0x09,
    IB_OPCODE_RDMA_WRITE_ONLY = 0x0a,
    IB_OPCODE_RDMA_WRITE_ONLY_WITH_IMMEDIATE = 0x0b,
    IB_OPCODE_RDMA_READ_REQUEST = 0x0c,
    IB_OPCODE_RDMA_READ_RESPONSE_FIRST = 0x0d,
    IB_OPCODE_RDMA_READ_RESPONSE_MIDDLE = 0x0e,
    IB_OPCODE_RDMA_READ_RESPONSE_LAST = 0x0f,
    IB_OPCODE_RDMA_READ_RESPONSE_ONLY = 0x10,
    IB_OPCODE_ACKNOWLEDGE = 0x11,
    IB_OPCODE_ATOMIC_ACKNOWLEDGE = 0x12,
    IB_OPCODE_COMPARE_SWAP = 0x13,
    IB_OPCODE_FETCH_ADD = 0x14,
    IB_OPCODE_DRIVER1 = 0x15,
    IB_OPCODE_SEND_LAST_WITH_INVALIDATE = 0x16,
    IB_OPCODE_SEND_ONLY_WITH_INVALIDATE = 0x17,

    /* real constants follow -- see comment about above IB_OPCODE()
       macro for more details */

       /* RC */
    IB_OPCODE(RC, SEND_FIRST),
    IB_OPCODE(RC, SEND_MIDDLE),
    IB_OPCODE(RC, SEND_LAST),
    IB_OPCODE(RC, SEND_LAST_WITH_IMMEDIATE),
    IB_OPCODE(RC, SEND_ONLY),
    IB_OPCODE(RC, SEND_ONLY_WITH_IMMEDIATE),
    IB_OPCODE(RC, RDMA_WRITE_FIRST),
    IB_OPCODE(RC, RDMA_WRITE_MIDDLE),
    IB_OPCODE(RC, RDMA_WRITE_LAST),
    IB_OPCODE(RC, RDMA_WRITE_LAST_WITH_IMMEDIATE),
    IB_OPCODE(RC, RDMA_WRITE_ONLY),
    IB_OPCODE(RC, RDMA_WRITE_ONLY_WITH_IMMEDIATE),
    IB_OPCODE(RC, RDMA_READ_REQUEST),
    IB_OPCODE(RC, RDMA_READ_RESPONSE_FIRST),
    IB_OPCODE(RC, RDMA_READ_RESPONSE_MIDDLE),
    IB_OPCODE(RC, RDMA_READ_RESPONSE_LAST),
    IB_OPCODE(RC, RDMA_READ_RESPONSE_ONLY),
    IB_OPCODE(RC, ACKNOWLEDGE),
    IB_OPCODE(RC, ATOMIC_ACKNOWLEDGE),
    IB_OPCODE(RC, COMPARE_SWAP),
    IB_OPCODE(RC, FETCH_ADD),
    IB_OPCODE(RC, SEND_LAST_WITH_INVALIDATE),
    IB_OPCODE(RC, SEND_ONLY_WITH_INVALIDATE),
};

enum rxe_hdr_type {
    RXE_LRH,
    RXE_GRH,
    RXE_BTH,
    RXE_RETH,
    RXE_AETH,
    RXE_ATMETH,
    RXE_ATMACK,
    RXE_IETH,
    RXE_RDETH,
    RXE_DETH,
    RXE_IMMDT,
    RXE_PAYLOAD,
    // used for timely algorithm
    RXE_TIMELY_TIMESTAMP,
    // used for dcqcn algorithm
    RXE_DCQCN_ECN,
    RXE_HPCC_HEADER,
    NUM_HDR_TYPES
};

enum rxe_hdr_mask {
    RXE_LRH_MASK = BIT(RXE_LRH),
    RXE_GRH_MASK = BIT(RXE_GRH),
    RXE_BTH_MASK = BIT(RXE_BTH),
    RXE_IMMDT_MASK = BIT(RXE_IMMDT),
    RXE_RETH_MASK = BIT(RXE_RETH),
    RXE_AETH_MASK = BIT(RXE_AETH),
    RXE_ATMETH_MASK = BIT(RXE_ATMETH),
    RXE_ATMACK_MASK = BIT(RXE_ATMACK),
    RXE_IETH_MASK = BIT(RXE_IETH),
    RXE_RDETH_MASK = BIT(RXE_RDETH),
    RXE_DETH_MASK = BIT(RXE_DETH),
    RXE_PAYLOAD_MASK = BIT(RXE_PAYLOAD),

    RXE_REQ_MASK = BIT(NUM_HDR_TYPES + 0),
    RXE_ACK_MASK = BIT(NUM_HDR_TYPES + 1),
    RXE_SEND_MASK = BIT(NUM_HDR_TYPES + 2),
    RXE_WRITE_MASK = BIT(NUM_HDR_TYPES + 3),
    RXE_READ_MASK = BIT(NUM_HDR_TYPES + 4),
    RXE_ATOMIC_MASK = BIT(NUM_HDR_TYPES + 5),

    RXE_RWR_MASK = BIT(NUM_HDR_TYPES + 6),
    RXE_COMP_MASK = BIT(NUM_HDR_TYPES + 7),

    RXE_START_MASK = BIT(NUM_HDR_TYPES + 8),
    RXE_MIDDLE_MASK = BIT(NUM_HDR_TYPES + 9),
    RXE_END_MASK = BIT(NUM_HDR_TYPES + 10),

    RXE_LOOPBACK_MASK = BIT(NUM_HDR_TYPES + 12),

    RXE_READ_OR_ATOMIC = (RXE_READ_MASK | RXE_ATOMIC_MASK),
    RXE_WRITE_OR_SEND = (RXE_WRITE_MASK | RXE_SEND_MASK),
};

#define OPCODE_NONE		(-1)
#define RXE_NUM_OPCODE		32

struct rxe_opcode_info {
    char *name;
    int	mask;
    int			length;
    int			offset[NUM_HDR_TYPES];
};

extern struct rxe_opcode_info rxe_opcode[RXE_NUM_OPCODE];
